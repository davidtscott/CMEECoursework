Starting weekly assessment for David, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 44.30 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, Assessment, Week5, Week2, Week4, .git, Week3

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************

# Compiled source #
###################
*.com
*.class
*.dll
*.exe
*.o
*.so
*.aux

# Packages #
############
# it's better to unpack these files and commit the raw source
# git has its own built in compression methods
*.7z
*.dmg
*.gz
*.iso
*.jar
*.rar
*.tar
*.zip

*.pdf

# Logs and databases #
######################
*.log
*.sql
*.sqlite

# OS generated files #
######################
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db



###python##
*.pyc
__pycache__/*

__pycache__

#jupyernotebok
.ipynb_checkpoints

##################### R ################
# History files
.Rhistory
.Rapp.history

# Session Data files
.RData

# Example code in package build process
*-Ex.R

# Output files from R CMD build
/*.tar.gz

# Output files from R CMD check
/*.Rcheck/

# RStudio files
.Rproj.user/

##
README.html

### week ###################
MiniProject/
Week9/
C_Week10/



# anyfile above 10mb
./Week5/Data/EU/g250_06.tif
./Week5/Data/EU/bio1_15.tif
./Week5/Data/EU/bio1_16.tif
./Week5/Data/EU/bio12_15.tif
./Week5/Data/EU/bio12_16.tif
./Week5/Data/SRTM_Channels_network/SRTM_Channels_network.dbf
./Week5/Data/SRTM_Channels_network/SRTM_Channels_network.shp
./Week5/Data/SAFE_layout_shapefiles/sloperaster.tif
./Week5/Data/Borneo/MODIS_red_reflectance.tif
./Week5/Data/Borneo/MODIS_blue_reflectance.tif
./Week5/Data/Borneo/MODIS_NIR_reflectance.tif
**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# README Document for CMEECourseWork Repository
## Author: David Scott - _david.scott18@imperial.ac.uk_
## Date: _OCT - NOV - DEC - 2018_

### For full course notes check out [The Multilingual Quantitative Biologist!](http://nbviewer.jupyter.org/github/mhasoba/TheMulQuaBio/blob/master/notebooks/Index.ipynb)
### Data and other resources are available at [TheMulQuaBio](https://mhasoba.github.io/TheMulQuaBio/) repository!

#### Description: 
Repository contains an individual directory for each weeks coursework, each further subdivided into four sub-directories; Code, Data, Results and Sandbox. Set working directory to Code. All scripts call data and output results to respective directories using relative paths. All scipts are annotated where appropriate.

#### Map of directories:
```
.
├── README.md
├── Assesment
├── Week1                 Unix & Shell Scripting
├── Week2                 Biological Computing in Python-1
├── Week3                 Biological Computing in R and Data Management Exploration & Visualisation in R 
|── Week4                 Statistics in R
├── Week5                 GIS
├── Week6                 Genomics & Bioinformatics
└── Week7                 Biological Computing in Python-2
    ├── Code
    ├── Data
    ├── Sandbox
    └── Results

8 directories

```
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 7 weekly directories: Week1, Week2, Week3, Week4, Week5, Week6, Week7

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox, Results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# README Document for CMEECourseWork Week2
## Author: David Scott - _david.scott18@imperial.ac.uk_
## Date: _OCT - 2018_

### Biological Computing in Python 1

#### Description: 
All scripts were written in Visual Studio Code for python3 and should run regardless of system type. Scripts, codes and results in respective directories. Map of directories and content provided below. Results files were gitignored but running scripts will regenerate them and send them to Results directory using relative paths.

#### Map of directories with short description of each script.
```
.
├── Code
│   ├── align_seqs_better.py :            DNA sequence alignment, improved version
│   ├── align_seqs_fasta.py :             Aligns any two fasta sequences from seperate files 
│   ├── align_seqs.py :                   DNA sequence alignment
│   ├── basic_csv.py :                    Script to show the use of csv module in python. 
│   ├── basic_io.py :                     Shows use of inputting and outputting data in files to scripts
│   ├── boilerplate.py :                  Basic boiler plate example, using sys module 
│   ├── cfexercises1.py :                 Control flow examples 
│   ├── cfexercises2.py :                 Six functions to show the use of modules for  manipulation and calculation of variables
│   ├── control_flow.py :                 Some functions exemplifying the use of control statements 
│   ├── debugme.py :                      Simple debug example fucntion.
│   ├── dictionary.py :                   Populates a dictionary from a list of tuples (Species name, Order)
│   ├── lc1.py :                          Three list comprehensions and three loops on a tuple of tuples.
│   ├── lc2.py :                          Extracts tuples from a tuple of tuples of rainfal data.
│   ├── loops.py :                        Basic boilerplate to demonstrate the use of loops in python 
│   ├── oaks_debugme.py :                 Simple debug example fucntion. : Functions to detect and print oaks of genus 'Quercus'.
│   ├── oaks.py :                         Using loops in python to manipulate data.
│   ├── scope.py :                        Example to show global variables 
│   ├── sysargv.py :                      Basic boiler plate example, using sys module 
│   ├── test_control_flow.py :            Some functions exemplifying the use of control statements
│   ├── tuple.py :                        Extracts tuples from within a tuple and outputs as seperate lines
│   └── using_name.py :                   Shows use of main 
├── Data
│   ├── align_seqs.csv
│   ├── bodymass.csv
│   ├── fasta
│   │   ├── 407228326.fasta
│   │   ├── 407228412.fasta
│   │   └── E.coli.fasta
│   ├── testcsv.csv
│   └── TestOaksData.csv
├── README.tmp
├── Results
│   ├── align_seqs_better.txt                   .gitignored
│   ├── align_seqs_fasta.txt                    .gitignored
│   ├── align_seqs.txt                          .gitignored
│   └── JustOaksData.csv                        .gitignored
└── Sandbox
    ├── testout.txt
    ├── testp.p
    └── test.txt

5 directories, 36 files

```
**********************************************************************

Found following files in results directory: align_seqs_fasta.csv, align_seqs.csv, .gitignore, align_seqs_better.txt...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 21 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, align_seqs_better.py, dictionary.py, debugme.py, scope.py, cfexercises1.py, tuple.py, basic_io.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018

"""
Completes two tasks (below), twice by using both list comprehension and loops
    1- creates a list of month, rainfall tuples where the rainfall 
    was above 100.0 mm

    2- creates list of month names where the rainfall was below 50.0 mm

""" 

__appname__ = '[lc2.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"




# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

rainfall_big = [item for item in rainfall if item[1] > 100.0]
# creates an object called rainfall_big.
# assigns every item (month, rain tuple) to rainfall_big with a 
#   rainfall (index[1]) above 100.0 
print(rainfall_big)
# prints object (list of tuples)

# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm.

rainfall_small = [item[0] for item in rainfall if item[1] < 50.0]
# creates a list object called rainfall_small.
# assigns every item[0] (month name) to rainfall_small with a 
#  rainfall (index[1]) below 50mm
print(rainfall_small)
# print object (list of months name)

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

#same as above but with loops
# here used 'rain' instead of 'item' as above. same principle
# both rain and item represent each tuple in rainfall. can use anyterm.

rainfall_b = [] 
rainfall_s = []
# created lists to be fed from the loop

for rain in rainfall:
# for each rain (tuple) in ranfall
    if rain[1] > 100.0:
        #if index 1 (rainfall) of tuple measures over 100.0
        rainfall_b.append(rain)
        #append the tuple (rain) to new set rainfall_.b
    elif rain[1] < 50.0:
        # selected tuples with rainfall (index 1) below 50.0 
        rainfall_s.append(rain[0])
        # only appended the month name to new object rainfall_s

#prints content of lists
print(rainfall_b)
print(rainfall_s)

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS
**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']

**********************************************************************

Code ran without errors

Time consumed = 0.03346s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2018

"""basic boiler plate example, using sys module """ 

__appname__ = '[python_boiletplate.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program" 

## imports ##
import sys 
# module to interface our program with the operating system 

## Constants ##

## functions ## 
def main(argv):
    """ Main entry point of the program """
    print ('This is a boilerplate') # four space indent 
    return 0             #used for debugging. 0 for success or failure

if __name__ == "__main__": 
    """Makes sure the "main" function is called from command line"""
    status = main(sys.argv)    
    sys.exit(status) 
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.02941s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# October 2018

""" Script to show the use of csv module in python. """

__appname__ = '[basic_csv.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import csv

## constants ##


## functions ## 

# Read a file containing: 
# 'Species','Intraorder','Family','Distribution', 'Body mass male (Kg)'
f = open('../Data/testcsv.csv','r')

# extract ad print desired data
csvread = csv.reader(f) 
temp = []
for row in csvread:
    temp.append(tuple(row))
    print(row)
    print("The species is", row[0]) 

f.close() # close file

# Write a file containing only species name and body mass
f = open('../Data/testcsv.csv','r') 
g = open('../Data/bodymass.csv','w') 

csvread = csv.reader(f) 
csvwrite = csv.writer(g) 
for row in csvread: 
    print(row) 
    csvwrite.writerow([row[0], row[4]]) 

f.close()
g.close() 
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.03227s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018

"""
Six functions to show the use of modules for 
manipulation and calculation of variable

Main argument prints results of each function 
using a default input value, to test functionality. 

Uses loops for factorial calculations. 

Takes input from command line.
""" 

__appname__ = '[cfexercises2.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"



#### Modified script and made it a module. 
#### All functions take arguements from the command line.
#### Added test arguements, to output from each function to show they work.


## imports ##
import sys

## constants ##


#### functions ####

def foo_1(x):
    """exponent, x to the power of 0.5"""
    #return x ** 0.5 #exponent, x to the power of 0.5 
    return "%d to the power of 0.5 is %f." % (x, x ** 0.5)

def foo_2(x, y):
    """returns the greater value of x and y"""
    if x > y:
        return "%d is greater than %d" % (x, y)
    return "%d is greater than %d" % (y, x)

def foo_3(x, y, z):
    """reassigns variables"""
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return [x, y, z]

def foo_4(x):
    """obtains factorial of x"""
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return "The factorial of %d is %d" % (x, result)

def foo_5(x): # a recursive function
    """uses recursion to obtain the factorial of x"""
    if x == 1:
        return 1
    return x * foo_5(x - 1) #!x factorial of x 

def foo_6(x): #calculate the factorial of x in a different way
    """calculates factorial of x"""
    facto = 1
    while x >= 1:
        facto = facto * x 
        x = x -1 
    return "The factorial is %d" % facto 

def main(argv):
    """Prints results of each function with a default numeric input,
    from foo_1() to foo_6() in numeric order. 
    Default value used: foo_1(8), 2(5, 15), 3(20, 10, 5), 4(5), 5(7), 6(8)."""
    print(foo_1(8))
    print(foo_2(5, 15))
    print(foo_3(20, 10, 5))
    print(foo_4(5))
    print(foo_5(7))
    print(foo_6(8))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)

####
# once script is run, these function can be called on  
# and the value of x can be changed within terminal e.g foo4(10)
**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
8 to the power of 0.5 is 2.828427.
15 is greater than 5
[10, 5, 20]
The factorial of 5 is 120
5040
The factorial is 40320

**********************************************************************

Code ran without errors

Time consumed = 0.02950s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Octber 2018

""" The output includes each best alignment 

Takes sequences as input from a single external file.
see '../Data/align_seqs_better.txt'

Saves best alignment and best score to a csv file.
see '../Results/align_seqs_better.txt'

""" 


__appname__ = '[align_seqs_better.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


# These are the two sequences to match
seq2 = "ATCGCCGGATTACGGG"
seq1 = "CAATTCGGAT"

## imports ##
import csv

# assign the longest sequence s1, and the shortest to s2
# l1 is the length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# function that computes a score
# by returning the number of matches 
# starting from arbitrary startpoint
def calculate_score(s1, s2, l1, l2, startpoint):
    """ Computes score of two DNA sequences aligned.
    startes from arbiary startpoint. returns number 
    of matches """
    # startpoint is the point at which we want to start
    matched = "" # contains string for alignement
    score = 0
    for i in range(l2):
        #pdb.set_trace()
        if (i + startpoint) < l1:
            # if its matching the character
            if s1[i + startpoint] == s2[i]:
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # build some formatted output
    print("." * startpoint + matched)        
    print("." * startpoint + s2) 
    print(s1)
    print(score) 
    print("")

    return score

calculate_score(s1, s2, l1, l2, 0)
calculate_score(s1, s2, l1, l2, 1)
calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score)
my_best_align = None
my_best_score = -1
best_ids = []     # creates emty list to store all best scores
for i in range(l1):
    z = calculate_score(s1, s2, l1, l2, i)  # function above
    g = open('../Results/align_seqs_better.txt','wb') #wb = writing binary. 
    #data written in the form of byte objects
    if z > my_best_score:       # if new score calculated(z) is greater than previous one
        my_best_align = "." * i + s2 #creates new best align
        my_best_score = z       # updates best score         
        best_ids.append(i)      # adds new one to it
    elif z == my_best_score:    # or if its equals old best score
        best_ids.append(i)      # also add to list of all best scores
    print(best_ids)             # pritn list of all best scores

outstr = ""
for x in best_ids:
    tempstr = "Offset = {}\n{}\n{}\nBest Score:{}\n\n\n".format(x, "." * x + s2, s1, my_best_score)
    outstr += tempstr

with open("../Results/align_seqs_better.txt", "w") as outfile:
    outfile.write(outstr)
**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5

.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2

.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2

-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5

[0]
.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2

[0]
..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1

[0]
...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1

[0]
....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1

[0]
.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2

[0]
......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4

[0]
**********************************************************************

Code ran without errors

Time consumed = 0.03172s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018

"""
Uses order as key and species names as values. 

Dictionary named taxa_dic

Some tuples share order thus, multiple species are assigned to 
each order in dictionary.

To use, run script, write taxa_dic['Carnivora'] into command line. 

Includes orders Chiroptera, Rodentia, Afrosoricida, Carnivora.

""" 

__appname__ = '[dictionary.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS

# Write your script here:

### created a dictionary whihc is a set of values indexed by keys. 
# in this case the keys are the order names
# the values are species names 
        
#taxa_dic = {k: v for v, k in taxa}

# create empty dictionary
taxa_dic={}

# v = value (species name)
# k = key (order)
for v, k in taxa:
    if k in taxa_dic:
        # append the new species to the order
        taxa_dic[k].append(v)
    else:
        # add new order to dic and assign its species name
        taxa_dic[k] = [v]

print(taxa_dic)

# to draw information from dictionary use:
### taxa_dic['Carnivora']

#### old solution ##

# first defined name of dictionary - taxa_dic
# then curly brackets start the dictionary construction
# then define first keys e.g 'Carnivora'
#       this is an order 
#now to give that key (order) its list of values (species names) do:
# 'Carnivora' : set(['x', 'y', 'z'])
# in this case 'x', 'y', 'z'  values will be species names of order carivora. 
# this creates a tuple of names indexed by an order 
# can be repeated for as many key : value pairs
# essentially a dictionary is a group indexed tuples 

# taxa_dic = {'Chiroptera' : set(['Myotis lucifugus']), 
#         'Rodentia' : set(['Gerbillus henleyi', 'Peromyscus crinitus', 
#         'Mus domesticus', 'Cleithrionomys rutilus']), 
#         'Afrosoricida' : set(['Microgale dobsoni', 'Microgale talazaci']),
#         'Carnivora' : set(['Lyacon pictus', 'Arctocephalus gazella', 
#         'Canis lupus'])}
**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Carnivora': ['Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus'], 'Chiroptera': ['Myotis lucifugus'], 'Afrosoricida': ['Microgale dobsoni', 'Microgale talazaci'], 'Rodentia': ['Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus', 'Cleithrionomys rutilus']}

**********************************************************************

Code ran without errors

Time consumed = 0.03204s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2018

""" simple debug example fucntion."""

__appname__ = '[debugme.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## functions ##

def createabug(x):
    """simple function with a bug to fix"""
    y = x**4
    z = 2
    y = y/z
    return y 

# fixed the bug, set z to equal integer of 2
# can reset z to equal 0. for bug

createabug(25)
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.03092s

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018

"""example to show global variables """ 

__appname__ = '[scope.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program" 

_a_global = 10

def a_function():
    """showing use of gloabl variables"""
    global _a_global 
    #without this the definition would not exist outside function
    _a_global = 5
    _a_local = 4
    print("Inside the function, the value is ", _a_global) 
    print("Inside the function, the value is ", _a_local)
    return None

a_function()
print("Outside the function, the value is ", _a_global) 
**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value is  5
Inside the function, the value is  4
Outside the function, the value is  5

**********************************************************************

Code ran without errors

Time consumed = 0.02451s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Control flow examples """
 
__appname__ = '[cfexercises1.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program" 

for i in range(3,17):
    print('hello')

for j in range(12):
    if j % 3 == 0:
        print('hello')

for j in range(15):
    if j % 5 == 3:
        print('hello')
    elif j % 4 == 3:
        print('hello')

z = 0 
while z != 15:
    print('hello') 
    z = z + 3 

z = 12
while z < 100:
    if z == 31:
        for k in range(7):
            print('hello')
    elif z == 18:
        print('hello')
    z = z + 1**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.02624s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018

"""
Extracts tuples from within a tuple and outputs as seperate lines

""" 

__appname__ = '[tuple.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )


# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by species 
# Hints: use the "print" command! You can use list comprehension!

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS

# for every tuple in object birds, print
# for tuple in birds:
#   print(tuple)
#   print("")

birdlist = [print(i,"\n") for i in birds]

# this prints each tuple seperately, seperated by blank line as opposed to
# printing entire block as would happen just used 'birds' 

# OR

#for tuple in birds:
#  print(tuple[0])
#  print(tuple[1])
#  print(tuple[2])
#  print(" ")
**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
('Passerculus sandwichensis', 'Savannah sparrow', 18.7) 

('Delichon urbica', 'House martin', 19) 

('Junco phaeonotus', 'Yellow-eyed junco', 19.5) 

('Junco hyemalis', 'Dark-eyed junco', 19.6) 

('Tachycineata bicolor', 'Tree swallow', 20.2) 


**********************************************************************

Code ran without errors

Time consumed = 0.03186s

======================================================================
Inspecting script file basic_io.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018

"""Shows use of inputting and outputting data in files to scripts"""

__appname__ = '[basic_io.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import pickle 

######################
# FILE INPUT
######################
# Open a file for reading ('r')
f = open('../Sandbox/test.txt', 'r')
# Use "implicit" for loop:
# if the object is a file, python will cycle over 
for line in f: 
    print(line) 

# Close the file 
f.close() 

# Same example, skip blank lines 
f = open('../Sandbox/test.txt', 'r')
for line in f: 
    if len(line.strip()) > 0:
        print(line) 

f.close() 

########################
# FILE OUTPUT 
########################
# Save the elements of a list to a file 
list_to_save = range(100) 

#open a file for writing ('w')
f = open('../Sandbox/testout.txt', 'w')
for i in list_to_save: 
    f.write(str(i) + '\n') ##Add a new line at the end 

f.close() 

######################
# STORING OBJECTS 
######################
# To save an object (even complex) for later use 
my_dictionary = {"a key": 10, "another key": 11} 

f = open('../Sandbox/testp.p', 'wb') 
## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again 
f = open('../Sandbox/testp.p', 'rb') 
another_dictionary = pickle.load(f) 
f.close() 

print(another_dictionary)
 **********************************************************************

Testing basic_io.py...

basic_io.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
First Line

Second Line

           

Third Line

           

Fourth Line

First Line

Second Line

Third Line

Fourth Line

{'another key': 11, 'a key': 10}

**********************************************************************

Code ran without errors

Time consumed = 0.03350s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018

"""
Object birds contains a tuple of tuples. Each tuple has the latin name,
common name and body mass of a bird species. 

Code in the script takes components of each tuple and assigns them to new list.

Each task is twice repeated, using both list comprehension and loops.   

The first one takes the latin name frome each tuple using index [0] and assigns 
it to a new list object. The second takes common name, index [1] 
and the third takes the body mass index [2]. 

""" 

__appname__ = '[lc1.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

# (2) Now do the same using conventional loops (you can shoose to do this 
# before 1 !). 

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS.


## 1 ## list comprehensions ##

## latin name of species
birds_latinname = [item[0] for item in birds] 
print(birds_latinname)
#selects birds latinname (index 0) from within each tuple
#   of the birds object
#   assigns it to object new "birds_latinname"
# prints content of birds_latin name
#   the latin name of each speces of birds

## common names of species 
birds_commonname = [item[1] for item in birds]
print(birds_commonname)
# same as above but for birds common name withn each tuple
#   index 1

## body mass of birds
birds_bodymass = [item[2] for item in birds]
print(birds_bodymass)
# same again but for birds body weight within each tuple
#   index 2


## 2 ## loops ##

## latin name of species
birds_latin_loops = []
# creates a list called birds_latin_loops
for item in birds: # start of loop
# for each item in object birds (tuple of tuples)
    birds_latin_loops.append(item[0]) 
    # appends birds latin name to birds_latin_loops
print(birds_latin_loops) #then print this list

## common names of species 
birds_common_loops = []
for item in birds:
    birds_common_loops.append(item[1])
print(birds_common_loops)
# same as above but this time selected index 1 - common names

## body mass of birds
birds_mass_loops = []
for item in birds:
    birds_mass_loops.append(item[2])
print(birds_mass_loops)
# selected item 2 - body mass
**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]
['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
[18.7, 19, 19.5, 19.6, 20.2]

**********************************************************************

Code ran without errors

Time consumed = 0.02904s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018

"""
Functions to detect and print oaks of genus 'Quercus'.

Dispays "FOUND AN OAK!" when oak species is detected.

Bug fixed of previous version (spelling)

Added doctests to test functionality of functions. 

All code is annotated within the script.

Author: David Scott (david.scott18@imperial.ac.uk)

""" 

__appname__ = '[oaks_debugme]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


## imports ##
import csv
import sys
import doctest
import pdb

#Define function
def is_an_oak(oakname):
    ## doctests within module
    """ Returns True if name starts with 'quercus', 
        otherwise returns False.
        
    >>> is_an_oak('Quercus robur')
    True
        
    >>> is_an_oak('Fraxinus excelsior')
    False

    >>> is_an_oak('Quercusstartswithaq fancythat')
    False

    """
    oakname = oakname.lower() #bug, quercus missing a u
    # Split string on space (" "), then take index [0] of the generated list.
    oakindex = oakname.split(" ")
    if len(oakindex[0]) != 7: #if length of first word not 7 characters
        return False # return it as false
    return oakname.startswith('quercus') # if
        

def main(argv): 
    """Takes data from input file, writes an output, 
    prints content and if it is a oak prints: 'FOUND AN OAK!'"""
    f = open('../Data/TestOaksData.csv','r')
    g = open('../Results/JustOaksData.csv','w')
    taxa = csv.reader(f)
    next(taxa) ## EXCLUDES HEADER BEING PRINTED!! 
    csvwrite = csv.writer(g)
    csvwrite.writerow(['Genus', 'species']) ## ADDS HEADER!! 
    # oaks = set()  
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):   #bug above interupted code here. 
        #did not recognise any oaks due to misspelling 
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])
    f.close()
    g.close()
    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod()
**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.06687s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2018

"""Using loops in python to manipulate data.""" 

__appname__ = '[oaks.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program" 

## Finds just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur', 
         'Fraxinus excelsior', 
         'Pinus sylvestris',
         'Quercus cerris', 
         'Quercus petraea',
        ]

def is_an_oak(name):
    """ return names is startd with 'quercus ' """
    return name.lower().startswith('quercus ')

##Using for loops 
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

##Using list comprehension 
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops) 

##Get names in UPPER CASE using list comprehensions 
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)
**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'QUERCUS ROBUR', 'QUERCUS PETRAEA', 'QUERCUS CERRIS'}
{'QUERCUS ROBUR', 'QUERCUS PETRAEA', 'QUERCUS CERRIS'}

**********************************************************************

Code ran without errors

Time consumed = 0.02939s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2018

"""basic boilerplate to demonstrate the use of loops in python """ 

__appname__ = '[loops.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program" 

# For loops in Python
for i in range(5):
    print(i) 

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

#creates a new total each time it loops
total = 0
summands = [0, 1, 11, 111, 1111] 
for s in summands:
    total = total + s 
    print(total)

# While loops in Python
z = 0 
while z < 100:
    z = z + 1
    print(z) 

b = True 
while b: 
    print("GERONIMO! infinite loop! ctrl+c to stop!")
# ctrl + c to stop
**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c
**********************************************************************

Code ran without errors

Time consumed = 10.25744s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018

""" shows use of main """ 

__appname__ = '[using_name.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


if __name__ == '__main__':
    #if being run by itself print this
    print('This program is being run by itself') 
else: 
    #if not, print this
    print('I am being imported from another module')  

### this can also be embedded into boilerplate.py
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.07181s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018 

""" Takes sequences as input from a single external file.
see '../Data/align_seqs.csv'

Saves best alignment and best score to a csv file.
see '../Results/align_seqs.csv'

All code is annotated within the script.

Author: David Scott (david.scott18@imperial.ac.uk)
"""

__appname__ = '[align_seqs.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"


# These are the two sequences to match
#seq2 = "ATCGCCGGATTACGGG"
#seq1 = "CAATTCGGAT"

## imports ##
import csv 

# read in data from csv file
with open('../Data/align_seqs.csv', 'r') as csvfile:
    DNAseqs = csv.reader(csvfile)
    for row in DNAseqs:
        seq1 = row[0]
        seq2 = row[1]


# assign the longest sequence s1, and the shortest to s2
# l1 is the length of the longest, l2 that of the shortest
l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# function that computes a score
# by returning the number of matches 
# starting from arbitrary startpoint
def calculate_score(s1, s2, l1, l2, startpoint):
    """ Computes score of two DNA sequences aligned.
    startes from arbiary startpoint. returns number 
    of matches """
    # startpoint is the point at which we want to start
    matched = "" # contains string for alignement
    score = 0
    for i in range(l2):
        #pdb.set_trace()
        if (i + startpoint) < l1:
            # if its matching the character
            if s1[i + startpoint] == s2[i]:
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # build some formatted output
    print("." * startpoint + matched)        
    print("." * startpoint + s2) 
    print(s1)
    print(score) 
    print("")

    return score

# calls function with arbitary start points
calculate_score(s1, s2, l1, l2, 0)
calculate_score(s1, s2, l1, l2, 1)
calculate_score(s1, s2, l1, l2, 5)

# now try to find the best match (highest score)
my_best_align = None
my_best_score = -1

for i in range(l1):
    z = calculate_score(s1, s2, l1, l2, i)
    if z > my_best_score:
        my_best_align = "." * i + s2
        my_best_score = z

print(my_best_align)
print(s1)
print("Best score:", my_best_score)

with open('../Results/align_seqs.txt','w') as outfile:
    outfile.write("My Best Score: {}\n".format(my_best_score)) 
    outfile.write("My Best Alignment: {}".format(my_best_align))   
**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5

.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2

.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2

-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5

.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2

..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1

...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1

....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1

.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2

......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4

.......-*-*-***-
.......CAA
**********************************************************************

Code ran without errors

Time consumed = 0.05141s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2018

"""basic boiler plate example, using sys module """ 

__appname__ = '[sysargv.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program" 

## imports ##
import sys

print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: " , str(sys.argv)) 
**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.02616s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: October 2018

"""Aligns any two .fasta sequences from seperate files. 
Script takes inputs from user in command line, 
otherwise has two default input .fasta files.  

for default files see:
    fasta_input('../Data/fasta/407228326.fasta')
    fasta_input('../Data/fasta/407228412.fasta')

""" 

__appname__ = '[align_seqs_fasta.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

## imports ##
import sys 
import csv 

## functions ##

def fasta_input(fastafile):
    """ Read DNA seq from .fasta file, skips header
    and returns the sequence as a string by removing end line character.
    module designed so not to have to replicate code for each file input.
     """
    with open(fastafile, 'r') as f1: #'with' closes the file automatically
        f1str = "" #creates blank string
        counter = 0 #counter, starts at 0 
        for line in f1: 
            if counter:  #if line 0 (header) skip it
                f1str += line.replace("\n", "") # if not, so this
            counter += 1
    return f1str  # closes off function


def calculate_score(s1, s2, l1, l2, startpoint):
    """ Computes score of two DNA sequences aligned.
    startes from arbiary startpoint. Returns number 
    of matches.
    """
    # startpoint is the point at which we want to start
    matched = "" # contains string for alignement
    score = 0
    for i in range(l2):
        #pdb.set_trace()
        if (i + startpoint) < l1:
            # if its matching the character
            if s1[i + startpoint] == s2[i]:
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # build some formatted output
    #print("." * startpoint + matched)        
    #print("." * startpoint + s2) 
    #print(s1)
    #print(score) 
    #print("")

    return score


def main(argv):
    """ takes input from command line or defaults to two fasta files mapped,
    assigns them to two variables. Checks length of sequences. 
    assigns the longer sequence to s1 variable and shorter to s2 variable."""
    # if three or more argv variables in command line (includes module)
    if len(argv) >= 3:  
        # assign the first file (variable [1]) to seq1
        seq1 = fasta_input(sys.argv[1])
        #assign the second file (variable [2]) to seq2
        seq2 = fasta_input(sys.argv[2])
    else:
        # or, if number of arguments less than three:
        seq1 = fasta_input('../Data/fasta/407228326.fasta')
        seq2 = fasta_input('../Data/fasta/407228412.fasta')
        # assign default files (with file path) to variable seq1 and seq2
    # assign the longest sequence to s1, and the shortest to s2
    # l1 is the length of the longest, l2 that of the shortest
    l1 = len(seq1) #finds lenth of seq and assgns to variable
    l2 = len(seq2)
    if l1 >= l2:    # if l1 (seq1) is longer than l2 (seq2)
        s1 = seq1   
        s2 = seq2   
    else:    # assigns the longest sequense as s1 and the shorter as s2
        s1 = seq2   
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths

    calculate_score(s1, s2, l1, l2, 0)
    calculate_score(s1, s2, l1, l2, 1)
    calculate_score(s1, s2, l1, l2, 5)

    # now try to find the best match (highest score)
    my_best_align = None
    my_best_score = -1

    for i in range(l1):
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = "." * i + s2
            my_best_score = z

    print(my_best_align)
    print(s1)
    print("Best score:", my_best_score)

    # save output to .txt file 
    with open('../Results/align_seqs_fasta.txt','w') as outfile:
        outfile.write("My Best Score: {}\n".format(my_best_score)) 
        outfile.write("My Best Alignment: \n{}".format(my_best_align)) 


if __name__ == "__main__":
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
............................................................................AAAAAAACAAAAAGATACATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATGATATATATATGATATATCTGATATATATACATATGGTATACATGAGATACATCATATGTATATATGGTATACATGAGATACATCATATGTATATATGGTATACATGAGATACATCATATGTATATATGGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCATATGTATACATGAGATACATCA
**********************************************************************

Code ran without errors

Time consumed = 3.36246s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Date: Oct 2018

"""Some functions exemplifying the use of control statements """ 
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time. 

__appname__ = '[control_flow.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program" 

## imports ##
import sys # module to interface our program with the operating system 

## Constants ##

## functions ## 
def even_or_odd(x=0): #if not specified, x should take value 0.
    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if # % here determines even or odd
        return "%d is Even!" % x 
    #%d is how to format print number. can be %s etc. % x the number to use 
    return "%d is Odd!" % x

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0: 
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest  = 4
    elif x % 3 == 0: 
        largest = 3
    elif x % 2 == 0: 
        largest = 2
    else: #When all other (if, elif) conditions are not met
        return "No divisor found for %d!" % x 
        #Each function can return a value or a variable.
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): # "range" returns a sequence of integers
        if x % i == 0: 
            print("%d is not a prime: %d is a divisor" % (x, i)) 
            #Print formatted text "%d %s %f %e" % (20,"30",0.0003,0.00003)
            return False 
    print("%d is a prime!" % x)
    return True 

def find_all_primes (x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
      if is_prime(i):
        allprimes.append(i) 
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes

def main(argv):
    """ main function to run all of them """
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
    sys.exit(status)
    **********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.03639s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# October 2018

""" Some functions exemplifying the use of control statements. """

__appname__ = '[test_control_flow.py]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__license__ = "License for this code/program" 
__version__ = '0.0.1'

## imports ##
import sys
import doctest # Import the doctest module

## function ##
def even_or_odd(x=0):
    """Find whether a number x is even or odd.
      
    >>> even_or_odd(10)
    '10 is Even!'
    
    >>> even_or_odd(5)
    '5 is Odd!'
    
    whenever a float is provided, then the closest integer is used:    
    >>> even_or_odd(3.2)
    '3 is Odd!'
    
    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'
    
    """
    #Define function to be tested
    if x % 2 == 0:
        return "%d is Even!" % x
    return "%d is Odd!" % x

####### I SUPPRESSED THIS BLOCK: WHY? #######

def main(argv): 
    """ Call even_or_odd function defined """
    print(even_or_odd(22))
    print(even_or_odd(33))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)
#############################################
    
doctest.testmod()   # To run with embedded tests
**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!

**********************************************************************

Code ran without errors

Time consumed = 0.07214s

======================================================================
======================================================================
Finished running scripts

Ran into 0 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!