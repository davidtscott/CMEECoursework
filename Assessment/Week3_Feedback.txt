Starting weekly assessment for David Thomas, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 2.94 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Assessment, Week2, .git, Week3

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
# Compiled source #
###################
*.com
*.class
*.dll
*.exe
*.o
*.so
*.aux

# Packages #
############
# it's better to unpack these files and commit the raw source
# git has its own built in compression methods
*.7z
*.dmg
*.gz
*.iso
*.jar
*.rar
*.tar
*.zip

# Logs and databases #
######################
*.log
*.sql
*.sqlite

# OS generated files #
######################
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

###python##
*.pyc

### week
Week4/
Week5/
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My CMEE Coursework Repository

Author : David Scott 
Contact: david.scott18@imperial.ac.uk

Within this CMEECourseWork directory can be found an individual directory for each week of course work undertaken. Each directory is further subdivided into four folders; Code, Data, Results and Sandbox. 

Within the Code directory can be found all code and scripts produced for that week. Each script call's data from the Data directory (../Data) where all data inputs are stored! Finally all output generated are sent and stored in the Results (../Results) directories. 

Each results directory contains a .gitignore file so as to keep the git repository clean. However all results can be regenerated by running the code provided on the data. 

Sandbox 

Software:
Ubunto
python3 
blah blah 
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week1, Week2, Week3

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: Code, Data, Results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# README Document for CMEECourseWork Week3
## Author: David Scott- _david.scott18@imperial.ac.uk_
## Date: _Oct - 2018_

### Description: [CMEE Course Work, Week 3. Work done primarily with R. All scipts were written with R studio. Scripts are stored in the Code directory and use relative paths to call data from the Data directory and all outputs are directed to the Results directory. Thus, set working directory to Code.] 

### Packages used: ggplot2, tidyr, plyr, dplyr, lattice.

### Map of directories with short description of each file. 
```
.
├── Code
│   ├── apply1.R : use of apply function '
│   ├── apply2.R : use of apply function '
│   ├── basic_io.R : A simple script to illustrate R input-output '
│   ├── boilerplate.R : example boilerplate in R '
│   ├── break.R : use of break in functions '
│   ├── browse.R : use of browse function '
│   ├── control.R : Example of control flow constructs in R '
│   ├── DataWrang.R : Wrangling data with base R and reshape2 package '
│   ├── DataWrangTidy.R : data wrangling with tidyr and dplyr '
│   ├── get_TreeHeight.py : Calculates tree height using trigonometric function in python
│   ├── get_TreeHeight.R : function to calculate tree hight using trigonometry ' : calculates tree heght using trigonmenric function. take input file from command line. outputs results to csv '
│   ├── Girko.R : Girko's Law Simulation "
│   ├── GPDDmap.R : creates a world map and plots data points using maps package '
│   ├── MyBars.R : Annotating Histogram '
│   ├── next.R : use of next in functions '
│   ├── plotLin.R : Mathematical Annotation '
│   ├── PP_Lattice.R : Lattice graphs with mean and median calc. by factor  '
│   ├── PP_Regress_loc.R : Linear regession . Faceted by 3 variables.  '
│   ├── PP_Regress.R : Linear Regression with plots. Faceted by 2 variables '
│   ├── preallocate.R : vetorization example '
│   ├── run_get_TreeHeight.sh : simple boilerplate for shell scripts '
│   ├── sample.R : run a simulation that involves sampling from a population '
│   ├── TAutoCorr.aux
│   ├── TAutoCorr.R : calculates autocorrelation of time series mean temperature data '
│   ├── TAutoCorr.tex : Time Series Autocorrelation of Key West Yearly Mean Tempertures (1901 - 2000) '
│   ├── TreeHeight.R : function to calculate tree hight using trigonometry '
│   ├── try.R : run a simulation that involves sampling from a population with try '
│   ├── Vectorize1.R : sums all elements of a matrix  '
│   └── Vectorize2.R : Runs the stochastic (with gaussian fluctuations) Ricker Eqn . '
├── Data
│   ├── EcolArchives-E089-51-D1.csv
│   ├── GPDDFiltered.RData
│   ├── KeyWestAnnualMeanTemperature.RData
│   ├── PoundHillData.csv
│   ├── PoundHillMetaData.csv
│   ├── Results.txt
│   └── trees.csv
├── README.md
└── Sandbox

3 directories, 37 files

```
**********************************************************************

Found following files in results directory: .gitignore...
Found 29 code files: browse.R, PP_Regress.R, apply1.R, sample.R, run_get_TreeHeight.sh, get_TreeHeight.py, boilerplate.R, TreeHeight.R, PP_Lattice.R, next.R, Girko.R, Vectorize1.R, break.R, plotLin.R, basic_io.R, Vectorize1.py, try.R, apply2.R, get_TreeHeight.R, TAutoCorr.R, Vectorize2.R, DataWrangTidy.R, preallocate.R, PP_Regress_loc.R, DataWrang.R, TAutoCorr.tex, MyBars.R, GPDDmap.R, control.R

Found the following extra files: .RData, .Rhistory
0.5 pt deducted per extra file

Current Points = 99.0

======================================================================
Testing script/code files...

======================================================================
Inspecting script file browse.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: use of browse function

rm(list=ls()) # clears workspace

Exponential <- function(N0 = 1, r = 1, generations = 10){
  # Runs a simulation of exponential growth
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations){
    N[t] <- N[t-1] * exp(r)
    browser()
  }
  return (N)
}

plot(Exponential(), type="l", main="Exponential growth")
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 

**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors

Time consumed = 0.10801s

======================================================================
Inspecting script file PP_Regress.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 29 2018
# Description: Linear Regression with plots. Faceted by 2 variables

rm(list = ls()) #clears workspaces
graphics.off() #clears any images

## Packages
library(ggplot2)
library(plyr)
library(dplyr)

# read data from file to dataframe
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv", stringsAsFactors=FALSE)

#initiate plot and assign data to variables
#subset graph by Type of feeding interactio and colour by Predator.lifestage
p <- ggplot(MyDF, aes(x = Prey.mass, y = Predator.mass, colour = Predator.lifestage)) +
      facet_grid(rows = vars(Type.of.feeding.interaction))

# add points of shape 3(crosses) and regression lines with standard error. 
# adjusted length and width of line.
p <- p + geom_point(shape = 3) + geom_smooth(method = "lm", se=TRUE, fullrange=TRUE, size = 0.5) 

# changed x and y axis to log10 and added labels
p <- p + scale_x_log10() + scale_y_log10() + xlab("Prey Mass in grams") + ylab("Predator mass in grams") 

# changes theme to black and white
# moves legned to bottom and displays in one row
p <- p + theme_bw() + theme(legend.position = "bottom") + guides(colour = guide_legend(nrow = 1))

# Open blank pdf page using a relative path
pdf("../Results/PP_Regress.pdf", 11.7, 8.3)
print(p)

#calculate reg results for fitted lines in each subset of data 
#fitted_models <- MyDF %>% group_by(Type.of.feeding.interaction, Predator.lifestage) %>% do(model = lm(Predator.mass ~ Prey.mass, data = .))

#fitted_models$model
#library(broom)
#a <- fitted_models %>% tidy(model) 
#b <- fitted_models %>% glance(model) 


## calculate reg results for fitted lines in each subset of data 
LinearOutput <- dlply(MyDF,.(Type.of.feeding.interaction, Predator.lifestage), function(x) lm(Predator.mass~Prey.mass, data = x))

# Extract Coeffieciets r2, intercept, slope and p value
CoefOut <- ldply (LinearOutput, function(x) {
  intercept <- summary(x)$coefficients[1]
  slope <- summary(x)$coefficients[2]
  p.value <- summary(x)$coefficients[8]
  r2 <- summary(x)$r.squared
  data.frame(r2, intercept, slope, p.value)})

# Extract F statistic
F.statistic <- ldply(LinearOutput, function(x) summary(x)$fstatistic[1])

# Merge F stat with rest of coefficients into one dataframe
OutputDF <- merge(CoefOut, F.statistic, by = c("Type.of.feeding.interaction", "Predator.lifestage"), all = TRUE)

# change name of 7th columm
names(OutputDF)[7] <- "F.statistic"

# write results to a csv file in the results directory 
write.csv(OutputDF, "../Results/PP_Regress_Results.csv", row.names = FALSE, quote = FALSE)

#?write.csv
**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:

Attaching package: ‘dplyr’

The following objects are masked from ‘package:plyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Error in facet_grid(rows = vars(Type.of.feeding.interaction)) : 
  unused argument (rows = vars(Type.of.feeding.interaction))
Execution halted

======================================================================
Inspecting script file apply1.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: use of apply function

rm(list=ls()) # clears workspace

# use of *apply functions
# vectorise data for you 

## apply: applying the same function to rows/colums of a matrix

## Build a random matrix
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 

**********************************************************************
 [1]  0.110761455  0.275727758 -0.225360480 -0.002018082 -0.253347105
 [6] -0.241520205  0.616833320 -0.124736964  0.246613251  0.078584712
 [1] 1.6631482 1.4218337 0.7243666 0.4135998 0.7430917 1.7292666 0.9207835
 [8] 2.0212676 0.8574322 1.0361843
 [1] -0.24325263  0.44625488 -0.16139439 -0.93709206  0.08837457  0.19083134
 [7]  0.46075345  0.07869024  0.26558985  0.29278242

**********************************************************************

Code ran without errors

Time consumed = 0.05943s

======================================================================
Inspecting script file sample.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: run a simulation that involves sampling from a population

rm(list=ls()) # clears workspace


x <- rnorm(50) #Generate your population
doit <- function(x){
  x <- sample(x, replace = TRUE)
  if(length(unique(x)) > 30) { #only take mean if sample was sufficient
    print(paste("Mean of this sample was:", as.character(mean(x))))}
  }

## Run 100 iterations using vectorization:
result <- lapply(1:100, function(i) doit(x))

## Or using a for loop: 
result <- vector("list", 100) #Preallocate/Initialize
for(i in 1:100){
  results[[i]] <- doit(x)
}
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Mean of this sample was: 0.0466920263448835"
[1] "Mean of this sample was: 0.229936097530229"
[1] "Mean of this sample was: -0.0442367057779481"
[1] "Mean of this sample was: 0.0364498694299256"
[1] "Mean of this sample was: -0.0909035224886922"
[1] "Mean of this sample was: 0.197914492933915"
[1] "Mean of this sample was: 0.0292403713394077"
[1] "Mean of this sample was: -0.0971605666286431"
[1] "Mean of this sample was: -0.0195003525122874"
[1] "Mean of this sample was: 0.10917414280328"
[
**********************************************************************

Encountered error:
Error: object 'results' not found
Execution halted

======================================================================
Inspecting script file run_get_TreeHeight.sh...

File contents are:
**********************************************************************
#!/bin/bash
# Author: David Scott David.Scott18@imperial.ac.uk
# Script: boilerplate.sh
# Desc: runs rscript and python3 scripts (both cal. tree height)
# Arguments: none
# Date: Oct 2018

Rscript --vanilla get_TreeHeight.R ../Data/trees.csv

python3 get_TreeHeight.py ../Data/trees.csv

**********************************************************************

Testing run_get_TreeHeight.sh...

Output (only first 500 characters): 

**********************************************************************
[1] "Tree height is: c(27.8021161438536, 45.2460250644405, 14.6654828109493, 14.9341751666304, 35.9703591412599, 32.4102133664874, 17.4582436344144, 30.1373803987097, 20.3124778877177, 24.4316633466933, 27.5021323376702, 25.1559006982628, 29.3924796426504, 28.186387176743, 30.7398877560462, 39.7375605141388, 24.6907361358239, 17.7598206600918, 20.8173463350902, 35.0453500297761, 31.8570793178491, 31.9386047488713, 13.4821498330136, 33.3266523194599, 30.2326960123414, 35.9513240857659, 21.94396700
**********************************************************************

Code ran without errors

Time consumed = 0.10913s

======================================================================
Inspecting script file get_TreeHeight.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Calculates tree height using trigonometric function in python""" 

__appname__ = '[Tree Heights]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

# modules used
import sys
import csv
import math
import os

# read distance, degrees and species names data into lists
distance = []
degrees = []
names = []
with open(sys.argv[1], 'r') as f:
    next(f)             # skips header
    treedata = csv.reader(f)
    for row in treedata:
            names.append(row[0])
            distance.append(row[1])
            degrees.append(row[2])

# converts items in list to floats
distance2 = [float(i) for i in distance]
degrees2 = [float(i) for i in degrees]

#create function to calculate height
def tree_height(degrees2, distance2): #(treedata): 
    """This function calculates heights of trees given distance of each tree 
    from its base and angle to its top, using  the trigonometric formula """
    heights = []
    for i, j in zip(distance2, degrees2):
        radians = i * math.pi / 180 #distance (i)
        heights.append(j * math.tan(radians)) #degrees (j)
    print("Calculated heights in meters are:")
    print(heights)

    # join lists 
    rows = zip(names, distance, degrees, heights)

    # take elements from command line input file and add to output filename
    a = os.path.splitext(sys.argv[1])[0]
    b = a.split("/")
    c = b[2]
    outputfilename = "../Results/" + c + "_treeheights.csv"

    #write to a csv file and add headers
    with open("outputfilename", "w") as g:
        writer = csv.writer(g)
        writer.writerow(("Species", "Distance.m", "Angel.degrees", "Tree.Height.m"))
        for row in rows:
            writer.writerow(row)
        print("Saved output to csv file: {}" .format(outputfilename))

tree_height(degrees2, distance2)
**********************************************************************

Testing get_TreeHeight.py...

get_TreeHeight.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "get_TreeHeight.py", line 20, in <module>
    with open(sys.argv[1], 'r') as f:
IndexError: list index out of range

======================================================================
Inspecting script file boilerplate.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: example boilerplate in R

rm(list=ls()) # clears workspace

# A boilerplate R script 

MyFunction <- function(Arg1, Arg2){

    # Statements involving Arg1, Arg2:
    print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
    print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type

    return (c(Arg1, Arg2)) #this is optional, but very useful 
}

MyFunction(1,2) #test the function
MyFunction("Riki", "Tiki") #A different test

# {} brackets tell R where specification of function start and end
# indentation not required like in python
#   but make code more readable
**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.08131s

======================================================================
Inspecting script file TreeHeight.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: function to calculate tree hight using trigonometry

rm(list=ls()) # clears workspace

# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

MyData <- read.csv("../Data/trees.csv", header = TRUE) # import data with headers
# using read.csv function. File path goes to Data directory

#functin using degrees to calculate radians 
#   and radian with distance to calculate height. 
TreeHeight <- function(degrees, distance){
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    print(paste("Tree height is:", height))
    return (height)
}

#creates a data frome (TreeDF) with data from MyData (imported at beginning from trees.csv)
# and calls function TreeHeight defined above
# calls it with MyData column 3 (degrees) and MyData column 2 (distance)
# and thus appends output of function from two inputs with MyData
TreeDF <- data.frame(MyData, TreeHeight(MyData[3], MyData[2]))
colnames(TreeDF)[4] <- "Tree.Height.m"
# names column 4 containing output of function as "Tree.Height.m"

write.csv(TreeDF, "../Results/TreeHts.csv", row.names = FALSE)
#write TreeDF data frame to a csv file called TreeHts.csv in Results directory
# does not include row names

# {} curly brackets required for multi line statements.
**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Tree height is: c(27.8021161438536, 45.2460250644405, 14.6654828109493, 14.9341751666304, 35.9703591412599, 32.4102133664874, 17.4582436344144, 30.1373803987097, 20.3124778877177, 24.4316633466933, 27.5021323376702, 25.1559006982628, 29.3924796426504, 28.186387176743, 30.7398877560462, 39.7375605141388, 24.6907361358239, 17.7598206600918, 20.8173463350902, 35.0453500297761, 31.8570793178491, 31.9386047488713, 13.4821498330136, 33.3266523194599, 30.2326960123414, 35.9513240857659, 21.94396700
**********************************************************************

Code ran without errors

Time consumed = 0.07503s

======================================================================
Inspecting script file PP_Lattice.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 26 2018
# Description: Lattice graphs with mean and median calc. by factor 

rm(list = ls()) # clears workspace
graphics.off() # closes all open graphics

## Packages 
library(lattice)
library(plyr)
library(dplyr)
require(tidyr)

#load data
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv")

#examie dataframe
dim(MyDF)
str(MyDF)
head(MyDF)
names(MyDF)

## draws and saves three lattic graphs by feding interaction type
# use of log of masses (or mass-ratios) for all three

# predator mass.   Pred_Lattice.pdf
pdf("../Results/Pred_Lattice.pdf", # Open blank pdf page using a relative path
    11.7, 8.3) # These numbers are page dimensions in inches
densityplot(~log(Predator.mass) | Type.of.feeding.interaction, data=MyDF, 
            main= "Density Plot by Feeding Interaction Type", xlab="Log Predator Mass (g)",
           col = "purple", scales=list(cex=1.2, col="red"))
graphics.off()

# prey mass.      Prey_Lattice.pdf
pdf("../Results/Prey_Lattice.pdf", 11.7, 8.3) 
densityplot(~log(Prey.mass) | Type.of.feeding.interaction, data=MyDF,
            main= "Density Plot by Feeding Interaction Type", xlab="Log Prey Mass (g)",
            col = "purple", scales=list(cex=1.2, col="red"))
graphics.off() 

# size ratio of predator mass over prey mass.   SizeRatio_Lattice.pdf
pdf("../Results/SizeRatio_Lattice.pdf",  11.7, 8.3) 
  densityplot(~(log(Predator.mass/Prey.mass)) | Type.of.feeding.interaction, data=MyDF,
            main= "Density Plot by Feeding Interaction Type", xlab="Log Pred/Prey Size Ratio (g)",
            col = "purple", scales=list(cex=1.2, col="red"))
graphics.off()

# Calculated mean and meadian log pred mass, prey mass, and pred prey size ratio, by feeding type

## Mean and median of log predator mass
#Mean
LogPredMean <- ddply(MyDF, .(Type.of.feeding.interaction), summarize, Pred.Mean=mean(log(Predator.mass)))
#Median
LogPredMedian <- ddply(MyDF, .(Type.of.feeding.interaction), summarize, Pred.Median=median(log(Predator.mass)))
#join both
LogPred <- join(LogPredMean, LogPredMedian, type ="inner")

## Mean and median of log prey mass
LogPreyMean <- ddply(MyDF, .(Type.of.feeding.interaction), summarize, Prey.Mean=mean(log(Prey.mass)))
LogPreyMedian <- ddply(MyDF, .(Type.of.feeding.interaction), summarize, Prey.Median=median(log(Prey.mass)))
LogPrey <- join(LogPreyMean, LogPreyMedian, type ="inner")

# join median and mean of log prey with that of log predator
LogPredPrey <- join(LogPred, LogPrey, type ="inner")

# Mean and median of log ratio mass
LogRatioMean <- ddply(MyDF, .(Type.of.feeding.interaction), summarize, Pred.Prey.Ratio.Mean=mean(log(Predator.mass/Prey.mass)))
LogRatioMedian <- ddply(MyDF, .(Type.of.feeding.interaction), summarize, Pred.Prey.Ratio.Median=median(log(Predator.mass/Prey.mass)))
LogRatio <- join(LogRatioMean, LogRatioMedian, type ="inner")

# join previous two joined with that fo ration. Created final dataframe
LogDF <- join(LogPredPrey, LogRatio, type ="inner")
print(LogDF)
# output results to a csv
write.csv(LogDF, "../Results/PP_Results.csv", row.names = FALSE)



**********************************************************************

Testing PP_Lattice.R...

Output (only first 500 characters): 

**********************************************************************
[1] 34931    15
'data.frame':	34931 obs. of  15 variables:
 $ Record.number              : int  1 2 3 4 5 6 7 8 9 10 ...
 $ In.refID                   : Factor w/ 1218 levels "07/08/12","111-10",..: 1000 1004 1007 1012 1013 1014 1015 1017 1018 1018 ...
 $ IndividualID               : Factor w/ 17625 levels "1","10","100",..: 1 8781 9875 10984 12076 13187 14298 15407 16518 16518 ...
 $ Predator                   : Factor w/ 93 levels "Acanthocepola sp.",..: 72 72 72 72 72 72 72 72 72 72 ...
 $ Pre
**********************************************************************

Encountered error:

Attaching package: ‘dplyr’

The following objects are masked from ‘package:plyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: tidyr
Joining by: Type.of.feeding.interaction
Joining by: Type.of.feeding.interaction
Joining by: Type.of.feeding.interaction
Joining by: Type.of.feeding.interaction
Joining by: Type.of.feeding.interaction

======================================================================
Inspecting script file next.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: use of next in functions

rm(list=ls()) # clears workspace

for (i in 1:10) {
  if ((i %% 2) == 0)
    next # pass to next iteration of loop
  print(i)
}
**********************************************************************

Testing next.R...

Output (only first 500 characters): 

**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.08840s

======================================================================
Inspecting script file Girko.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 29 2018
# Description: Girko's Law Simulation

rm(list = ls()) 
graphics.off() 

build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix

M <- matrix(rnorm(N * N), N, N) # Build the matrix

eigvals <- eigen(M)$values # Find the eigenvalues

eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe

my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse

names(ellDF) <- c("Real", "Imaginary") # rename the columns


# Plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# Add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# Add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))

# Save as pdf 
pdf("../Results/Girko.pdf") # Open blank pdf page using a relative path
print(p)
graphics.off() 
**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Error in ggplot(eigDF, aes(x = Real, y = Imaginary)) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file Vectorize1.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: sums all elements of a matrix 

rm(list=ls()) # clears workspace

M <- matrix(runif(1000000),1000,1000)

SumAllElements <- function(M){
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]){
    for (j in 1:Dimensions[2]){
      Tot <- Tot + M[i,j]
    }
  }
  return (Tot)
}

## This on my computer takes about 1 sec
print(system.time(SumAllElements(M)))
## While this takes about 0.01 sec
print(system.time(sum(M)))

#system.time function calculates time taken by code
#sum() function 100 times faster than SumAllElements()
# as it uses vectorisation, avoiding the amount of loops used by SumAllElements
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 

**********************************************************************
   user  system elapsed 
  0.080   0.000   0.079 
   user  system elapsed 
  0.004   0.000   0.002 

**********************************************************************

Code ran without errors

Time consumed = 0.21790s

======================================================================
Inspecting script file break.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: use of break in functions

rm(list=ls()) # clears workspace

i <- 0 #initialize i
  while(i < Inf) {
    if (i == 20) {
      break
      } # Break out of the while loop!
    else {
      cat("i equals " , i , " \n")
      i <- i + 1 # Update i
    }
  }
**********************************************************************

Testing break.R...

Output (only first 500 characters): 

**********************************************************************
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  
i equals  10  
i equals  11  
i equals  12  
i equals  13  
i equals  14  
i equals  15  
i equals  16  
i equals  17  
i equals  18  
i equals  19  

**********************************************************************

Code ran without errors

Time consumed = 0.08292s

======================================================================
Inspecting script file plotLin.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 29 2018
# Description: Mathematical Annotation

rm(list = ls()) 
graphics.off() 

# create data
x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
  intercept = my_lm$coefficients[1][1],
  slope = my_lm$coefficients[2][1],
  colour = "red")
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                   parse = TRUE, size = 6, 
                   colour = "blue")

#save plot
pdf("../Results/MyLinReg.pdf") # Open blank pdf page using a relative path
print(p)
graphics.off() 
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Error in ggplot(my_data, aes(x = x, y = y, colour = abs(my_lm$residual))) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file basic_io.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: A simple script to illustrate R input-output

rm(list=ls()) # clears workspace

# Run line by line and check inputs outputs to understand what is happening

MyData <- read.csv("../Data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../Results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../Results/MyData.csv",append=TRUE) # Append to it 

write.csv(MyData, "../Results/MyData.csv", row.names = TRUE) # write row names

write.table(MyData, "../Results/MyData.csv", col.names = FALSE) # ignore column names
**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Warning message:
In write.table(MyData[1, ], file = "../Results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file Vectorize1.py...

File contents are:
**********************************************************************
#!/usr/bin/python

""" Compares speed of two functions with and without loops""" 

__appname__ = '[Vectorize1]'
__author__ = 'David Scott (david.scott18@imperial.ac.uk)'
__version__ = '0.0.1'
__license__ = "License for this code/program"

# packages
import numpy as np 
import time

# creates random array of dimension 1000 * 10000
#   with uniform distribution
M = np.random.rand(1000, 1000)

# define function to count each element or array M
start1 = time.time()  # starts timer
def SumAllElements(M):
    tot = 0
    for i in np.nditer(M): 
        tot += i
    return tot
end1 = time.time()  # ends timer

SumAllElements(M) #calls function with input

# sum function does that same as above but without loops
start2 = time.time() # starts timer
SumFuntion = sum(M)
end2 = time.time() # ends timer

# print speed of functiosn to compare
print("Speed of function defined using loops:", end1 - start1) 
print("Speed of sum function without loops:", end2 - start2) 
**********************************************************************

Testing Vectorize1.py...

Vectorize1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
('Speed of function defined using loops:', 9.5367431640625e-07)
('Speed of sum function without loops:', 0.0011870861053466797)

**********************************************************************

Code ran without errors

Time consumed = 0.36368s

======================================================================
Inspecting script file try.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: run a simulation that involves sampling from a population with try

rm(list=ls()) # clears workspace


x <- rnorm(50) #Generate your population
doit <- function(x){
  x <- sample(x, replace = TRUE)
  if(length(unique(x)) > 30) {#only take mean if sample was sufficient
    print(paste("Mean of this sample was:", as.character(mean(x))))
  } 
  else {
    stop("Couldn't calculate mean: too few unique points!")
  }
}

## Try using "try" with vectorization:
result <- lapply(1:100, function(i) try(doit(x), FALSE))

## Or using a for loop:
result <- vector("list", 100) #Preallocate/Initialize
for(i in 1:100) {
  result[[i]] <- try(doit(x), FALSE)
}
**********************************************************************

Testing try.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Mean of this sample was: 0.150269819202444"
[1] "Mean of this sample was: -0.0171094668366207"
[1] "Mean of this sample was: -0.0339590886212199"
[1] "Mean of this sample was: -0.0625224437197615"
[1] "Mean of this sample was: 0.0209064585113901"
[1] "Mean of this sample was: -0.173538936329563"
[1] "Mean of this sample was: -0.147599462480093"
[1] "Mean of this sample was: -0.229822239050126"
[1] "Mean of this sample was: 0.12445626350413"
[1] "Mean of this sample was: 0.243195016389307"
[1
**********************************************************************

Encountered error:
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!
Error in doit(x) : Couldn't calculate mean: too few unique points!

======================================================================
Inspecting script file apply2.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: use of apply function

rm(list=ls()) # clears workspace

SomeOperation <- function(v){ # if sum of v greaater than 0, multiply it by 100
  if (sum(v) > 0){
    return (v * 100)
  }
  return (v)
}

M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation))
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 

**********************************************************************
             [,1]        [,2]        [,3]       [,4]       [,5]        [,6]
 [1,] -1.44804396 -1.99706638 -0.21521404  131.69722 176.780809  -72.802277
 [2,]  1.03406180 -0.63151623 -0.08330414   98.66460  85.624126   -7.142567
 [3,] -1.16103640 -0.30178469  0.28794289  119.09056 130.981209  -93.026573
 [4,]  0.28127395 -0.77694912 -0.02633979  -59.43152 -72.333154  -19.971182
 [5,] -0.22723561 -1.60452539  0.15749836  140.54877  53.996492   81.372195
 [6,] -1.16345245  2.50283365 -0.57383530 -10
**********************************************************************

Code ran without errors

Time consumed = 0.08129s

======================================================================
Inspecting script file get_TreeHeight.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: calculates tree heght using trigonmenric function. take input file from command line. outputs results to csv

rm(list=ls()) # clears workspace

args = commandArgs(trailingOnly=TRUE)
# enables command line arguments

# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

# test if there is at least one argument given in command line: if not, return an error
if (length(args)==0) {
  stop("At least one argument must be supplied (input file).n", call.=FALSE)
} 

MyData <- read.csv(args[1], header = TRUE) # import with headers
#reads content of a csv file given in command line (argument one)
# assigns content to MyData variable

#functin using degrees to calculate radians 
#   and radian with distance to calculate height. 
TreeHeight <- function(degrees, distance){
  radians <- degrees * pi / 180
  height <- distance * tan(radians)
  print(paste("Tree height is:", height))
  return (height)
}

#creates a data frome (TreeDF) with data from MyData (imported at beginning from trees.csv)
# and calls function TreeHeight defined above
# calls it with MyData column 3 (degrees) and MyData column 2 (distance)
# and thus appends output of function from two inputs with MyData
TreeDF <- data.frame(MyData, TreeHeight(MyData[3], MyData[2]))
colnames(TreeDF)[4] <- "Tree.Height.m"
# names column 4 containing output of function as "Tree.Height.m"

library(tools)
inputfile_name <- file_path_sans_ext(basename(args[1]))
# strips the extension and file path from file given as agrument one in command line
outputfile_name <- paste("../Results/", inputfile_name, "_treeheights.csv", sep = "")
# paste new file path , extension and addition to name together and assigns to variable
print(outputfile_name)#prints new name of output file
write.csv(TreeDF, outputfile_name, row.names = FALSE)
# saves dataframe (TreeDF) to file named above. 
**********************************************************************

Testing get_TreeHeight.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Error: At least one argument must be supplied (input file).n
Execution halted

======================================================================
Inspecting script file TAutoCorr.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: calculates autocorrelation of time series mean temperature data

rm(list=ls()) # clears workspace

#Temperature data from Key West, Florida for 21st Century
# yeasr 1901 to 2000
load("../Data/KeyWestAnnualMeanTemperature.RData")
# loads data from data directory
# .RData taken from mulquo course page

#ats is automatic name for data from a .RData file

TempData <- ats #assigns to variable TempData
print(TempData) #print data
#copied from downloaded version
# wget https://.... gave error

str(TempData)
head(TempData) 
tail(TempData)
names(TempData) # prints column names

plot(TempData) #plot data
print("Plotted TempData")

print("Each year temperature was recorded:")
TempData[,1] # prints column 1 (years)
print("Each temperature recorded:")
TempData[,2]

keytemps <- TempData[,2] #assigns mean temperature (without corresponding year)
# to keytemps

######### AUTOCORRELATION #########
?cor()
#autocorrelation to asses if time series (mean temp)
# is dependent on its past 
# look at pairs. in this case 100 observations = 99 pairs
# pairs take form of (x[t],x[t-1])
# t is observatin index
# varies from 2 to 100 
# estimated sample correlation of these pairs is the lag-1 autocorrelation
#  of our data keytemps. 

#### create pairs of observations #####
# two vectors each of lenth n-1 (100 - 1)
#   thus rows are (x[t],x[t-1])

# Defines x_t0 as vector x[-1]
x_t0 <- keytemps[-1]

# Defines x_t1 as vector x[-n]
x_t1 <- keytemps[-100]

# Confirms that x_t0 and x_t1 are (x[t], x[t-1]) pairs  
head(cbind(x_t0, x_t1))

# Plots x_t0 and x_t1
plot(x_t0, x_t1)
print("Plotted (x_t0, x_t1)")

# View the correlation between x_t0 and x_t1
# apply cor() function to estimate lag-1 autocorrelation 
autocor <- cor(x_t0, x_t1)
print(paste("lag -1 autocorrelation of mean temperatures:", autocor))

### ALTERNTIVE METHOD (not base R) ##
# Use acf with x
#lag.max = 1 creates a single lag period
#acf(keytemps, lag.max = 1, plot = FALSE)

# difference between method above and alternatve method
# Confirm that difference factor is (n-1)/n 
# cor(x_t1, x_t0) * (100-1)/100

corfun <- function(keytemps){
  y_t0 <- sample(keytemps[-1], replace = TRUE)
  y_t1 <- sample(keytemps[-100], replace = TRUE)
  cor(y_t0, y_t1)
}
# function defined that creates (x[t],x[t-1]) pairs as above
# from keytemps and does so randomly
# generating random permutations
result <- lapply(1:10000, function(i) corfun(keytemps))
#  lapply function feeds corfun function 10,000 times with key temps data
# stores data for ech randomly permutated year sequence and stores it
result.numeric <- as.numeric(result)
# mutates results to numeric

print(result.numeric)

hist(result.numeric, col="gray", xlab="AutoCorrelations", main="KeyWest Temp Data (1901 - 2000)")
# histogram of results with heading and labels
abline(v = autocor, col = "red", lwd = 2)
#add abline to show where the initial correlation fell inrelation to the 10000

#par(mfrow = c(1,1))

length(result.numeric[result.numeric > autocor])/length((result.numeric)) 
# calculates the fraction of result.numeric (result from 10,000 random permutations)
# greater than first autocorrelation (autocor)
# used as an approximate p - value

# By looking at the abline i appears the intial correlation result autocor) 
# falls within 5% confidence interval 
# thus 95% confident not random. 

**********************************************************************

Testing TAutoCorr.R...

Output (only first 500 characters): 

**********************************************************************
    Year     Temp
1   1901 23.75000
2   1902 24.66667
3   1903 24.71667
4   1904 24.51667
5   1905 24.88333
6   1906 24.63333
7   1907 25.24167
8   1908 24.90000
9   1909 24.76667
10  1910 24.02500
11  1911 25.28333
12  1912 25.20833
13  1913 25.19167
14  1914 24.70000
15  1915 24.56667
16  1916 24.83333
17  1917 24.64167
18  1918 25.24167
19  1919 25.17500
20  1920 24.78333
21  1921 25.40000
22  1922 25.55833
23  1923 25.21667
24  1924 25.19167
25  1925 25.46667
26  1926 25.05000
27  1927 25.641
**********************************************************************

Code ran without errors

Time consumed = 0.70547s

======================================================================
Inspecting script file Vectorize2.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date: October 2018
# Description: Runs the stochastic (with gaussian fluctuations) Ricker Eqn .

rm(list=ls())

stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{                # runif here makes it stchastic
  #initialize
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
  
  for (pop in 1:length(p0)) #loop through the populations
  {   # each rep of for loop, R has to re-size the vector and reallocate memory
    for (yr in 2:numyears) #for each pop, loop through the years
    {
      N[yr,pop]<-N[yr-1,pop]*exp(r*(1-N[yr-1,pop]/K)+rnorm(1,0,sigma))
    }
  }
 return(N)

}

print("Stochastic Ricker takes:")
print(system.time(res2<-stochrick()))

# Now write another function called stochrickvect that vectorizes the above 
# to the extent possible, with improved performance: 

# vectorised 

rm(list=ls())

stochrickvect<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
    for (yr in 2:numyears) #for each pop, loop through the years
    {
      N[yr,]<-N[yr-1,]*exp(r*(1-N[yr-1,]/K)+rnorm(1,0,sigma))
  }
  return(N)
}
# removed pop loop and removed it from equation.
# years = t

print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))

**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Stochastic Ricker takes:"
   user  system elapsed 
  0.256   0.000   0.256 
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.012   0.000   0.011 

**********************************************************************

Code ran without errors

Time consumed = 0.34596s

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: data wrangling with tidyr and dplyr

rm(list=ls()) # clears workspace

################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

## Script edited to use dplyr and tidyr packages 
##   instead of reshape2 and base R
# Old code left in to but hashed out, to show compare methodology

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv",header = F)) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",header = T, sep=";", stringsAsFactors = F)

############# Inspect the dataset ###############

require(dplyr)
require(tidyr)

#head(MyData) # prints first 6 rows and headers
dplyr::tbl_df(MyData) #like head()
#dim(MyData) # prints dimensions
dplyr::dim_desc(MyData) #like dim()
#str(MyData) # prints structure
dplyr::glimpse(MyData) #like str()
#fix(MyData) #you can also do this
utils::View(MyData) #same as fix()
#fix(MyMetaData)
utils::View(MyMetaData) #same as fix()

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
#head(MyData)
dplyr::tbl_df(MyData) #like head()
#dim(MyData)
dplyr::dim_desc(MyData) #like dim()

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

rownames(TempData) <- NULL  # removes row names
#head(TempData)
dplyr::tbl_df(TempData) #like head()
############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

#?melt #check out the melt function
?gather #check out the gather function from tidyr package

#MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
MyWrangledData <- TempData %>% tidyr::gather(., Species, count, -Cultivation, -Block, -Plot, -Quadrat) %>% mutate(Cultivation = as.factor(Cultivation), Block = as.factor(Block), Plot = as.factor(Plot), Quadrat = as.factor(Quadrat), count = as.integer(count))
# pipes data from TempData to tidyr function gather (alternative to melt function)
# assigns variables, -
# pipe to mutate function and change them into factors and integer variables. 

# melt collapses daat in wide format and stacks it into singl column
#head(MyWrangledData); tail(MyWrangledData)
dplyr::tbl_df(MyWrangledData); tail(MyWrangledData)

# assign the correct data type of each row
#MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
#MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
#MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
#MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
#MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
#as.factor creates a factor column

#str(MyWrangledData)
dplyr::glimpse(MyWrangledData) #like str()
#head(MyWrangledData)
dplyr::tbl_df(MyWrangledData) #like head()
#dim(MyWrangledData)
dplyr::dim_desc(MyWrangledData) #like dim()

############# Exploring the data (extend the script below)  ###############

# from plyr to dplyr
# from reshape2 to tidyr

dplyr::tbl_df(MyWrangledData) #like head()
dplyr::glimpse(MyWrangledData) #like str()
utils::View(MyWrangledData) #same as fix()
dplyr::filter(MyWrangledData, Count > 100) #like subset()
dplyr::slice(MyWrangledData, 10:15) # Look at an arbitrary set of data rows
**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 

**********************************************************************
# A tibble: 45 x 60
   V1       V2     V3     V4    V5    V6    V7    V8    V9    V10   V11   V12  
   <chr>    <chr>  <chr>  <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr> <chr>
 1 Cultiva… octob… octob… octo… octo… octo… may   may   may   may   may   march
 2 Block    a      a      a     a     a     a     a     a     a     a     a    
 3 Plot     1      1      1     1     1     2     2     2     2     2     3    
 4 Quadrat  Q1     Q2     Q3    Q4    Q5    Q1    Q2    Q3    Q4    Q5    Q1   
 
**********************************************************************

Encountered error:
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Loading required package: tidyr
Loading required package: reshape2

Attaching package: ‘reshape2’

The following object is masked from ‘package:tidyr’:

    smiths

Error in filter_impl(.data, quo) : 
  Evaluation error: object 'Count' not found.
Calls: <Anonymous> ... as.data.frame -> filter -> filter.tbl_df -> filter_impl -> .Call
Execution halted

======================================================================
Inspecting script file preallocate.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date: October 2018
# Description: vetorization example

rm(list=ls()) # clears workspace

a <- NA
for (i in 1:100000) {
  a <- c(a, i)
}
print(a)
## This on my computer takes about 1 sec
print(system.time(SumAllElements(a)))
## While this takes about 0.01 sec
print(system.time(sum(a)))

########################

a <- rep(NA, 1000000)

for (i in 1:1000000) {
  a[i] <- i
}
print(a)
## This on my computer takes about 1 sec
print(system.time(SumAllElements(a)))
## While this takes about 0.01 sec
print(system.time(sum(a)))
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 10.00411s

======================================================================
Inspecting script file PP_Regress_loc.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 31 2018
# Description: Linear regession . Faceted by 3 variables. 

rm(list = ls()) 
graphics.off() 

## Packages
library(plyr)
library(dplyr)

# read data from file to dataframe
MyDF <- read.csv("../Data/EcolArchives-E089-51-D1.csv", stringsAsFactors=FALSE)

## calculate reg results for fitted lines in each subset of data 
LinearOutput2 <- dlply(MyDF,.(Type.of.feeding.interaction, Predator.lifestage, Location), function(x) lm(Predator.mass~Prey.mass, data = x))

# Extract Coeffieciets r2, intercept, slope and p value
CoefOut2 <- ldply (LinearOutput2, function(x) {
  intercept <- summary(x)$coefficients[1]
  slope <- summary(x)$coefficients[2]
  p.value <- summary(x)$coefficients[8]
  r2 <- summary(x)$r.squared
  data.frame(r2, intercept, slope, p.value)})

# Extract F statistic
F.statistic2 <- ldply(LinearOutput2, function(x) summary(x)$fstatistic[1])

# Merge F stat with rest of coefficients into one dataframe
OutputDF2 <- merge(CoefOut2, F.statistic2, by = c("Type.of.feeding.interaction", "Predator.lifestage", "Location"), all = TRUE)

# change name of 7th columm
names(OutputDF2)[7] <- "F.statistic"
OutputDF2
# write results to a csv file in the results directory 
write.csv(OutputDF2, "../Results/PP_Regress_loc_Results.csv", row.names = FALSE, quote = FALSE)
**********************************************************************

Testing PP_Regress_loc.R...

Output (only first 500 characters): 

**********************************************************************
   Type.of.feeding.interaction Predator.lifestage
1                insectivorous   larva / juvenile
2                  piscivorous              adult
3                  piscivorous              adult
4                  piscivorous              adult
5                  piscivorous              adult
6                  piscivorous              adult
7                  piscivorous              adult
8                  piscivorous              adult
9                  piscivorous              adult
1
**********************************************************************

Encountered error:

Attaching package: ‘dplyr’

The following objects are masked from ‘package:plyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Warning messages:
1: In summary.lm(x) : essentially perfect fit: summary may be unreliable
2: In summary.lm(x) : essentially perfect fit: summary may be unreliable
3: In summary.lm(x) : essentially perfect fit: summary may be unreliable
4: In summary.lm(x) : essentially perfect fit: summary may be unreliable
Warning message:
In summary.lm(x) : essentially perfect fit: summary may be unreliable

======================================================================
Inspecting script file DataWrang.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: Wrangling data with base R and reshape2 package

rm(list=ls()) # clears workspace

################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../Data/PoundHillData.csv",header = F)) 

# header = true because we do have metadata headers
MyMetaData <- read.csv("../Data/PoundHillMetaData.csv",header = T, sep=";", stringsAsFactors = F)

############# Inspect the dataset ###############
head(MyData) # prints first 6 rows and headers
dim(MyData) # prints dimensions
str(MyData) # prints structure
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

rownames(TempData) <- NULL  # removes row names
head(TempData)

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
head(MyWrangledData); tail(MyWrangledData)
# melt collapses daat in wide format and stacks it into singl column

# assign he correct data type of each row
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
#as.factor creates a factor column

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

# from plyr to dplyr
# from reshape2 to tidyr

require(dplyr)
require(tidyr)

dplyr::tbl_df(MyWrangledData) #like head()
dplyr::glimpse(MyWrangledData) #like str()
utils::View(MyWrangledData) #same as fix()
dplyr::filter(MyWrangledData, Count > 100) #like subset()
dplyr::slice(MyWrangledData, 10:15) # Look at an arbitrary set of data rows
dplyr::tbl_df(MyData)
**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 

**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Code ran without errors

Time consumed = 10.00388s

======================================================================
Inspecting script file TAutoCorr.tex...

File contents are:
**********************************************************************
\documentclass[12pt]{article}
\title{Time Series Autocorrelation of Key West Yearly Mean Tempertures (1901 - 2000)}
\usepackage{graphicx}
\author{David Scott}
\date{24/10/2018}
\begin{document}
    \maketitle

    \begin{abstract}
        To determine if mean temperature data are significantly correlated with the succesive across time (years) in Key West, Florida. 
        Time series used included data from the year 1901 to 2000. A lag -1 autocorrelation was used and gave a weak r score of 0.326. Random permutated pairs were also 
        generated from the data ten thousand times and tested. This created a random sample to test initial correlation result against. the fraction of these 
        that were greater than intiial correlation was 4e-04. This suggests correlation was non-random. Thus the effect from year to year was significant but weak.  
    \end{abstract} 

    \section{Introduction}
        In class exercise to investigate if mean temperatures from one year are
        significantly correlated with the successive year. 
        Autocorrelation examines data as pairs asseses if a time series is 
        dependent on its past. Pairs of data take form of:
        \begin{equation}
        (x[t],x[t-1]) \  \
        t = observation index. 
        \end{equation}
        Estimated sample correlation of these pairs is the lag -1 autocorrelation. 

    \section{Methodology}
        To calculate the lag -1 autocorrelation, a time series of yearly mean temperatures collected in Key West, 
        Florida from the year 1901 to 2000. This data was imported into RStudio environment. 
        An initial correlation score was calculated using each succesive pair in the sequence. 
        Subsequently repeated calculation ten thousand times by randomly permutating the time series and
        the correlation coefficient was recalculated for each year sequence. Finally the 
        fraction of the ten thousand correlation coefficient that were greater than the 
        initial autocorrelation was calculated as a p value. 

    \section{Results}
        From the initial correlation, an estimated lag-1 autocorrelation
        score of 0.326 was calculated. This is represented by the red 
        abline in figure 1. The autocorrelations generated through 
        the random permutations are displayed as a histogram in figure 1. The fraction of 
        these that were than 0.326 was 4e-04. The abline suggests 
        in figure 1 the intial correlation result falls within the 5% confidence interval. 
        
            \begin{figure}[!h]
            \begin{center}
            \includegraphics[width=8cm]{../Results/Rplot.png}
            \caption{Frequency of autocorrelations generated from 10,000 random permutations of Key West yearly mean temperature data. 
                Includes abline (red) of autocorrelation of one single correlation of succesive years}
            \end{center}
            \end{figure}

    \section{Discussion}
        In examining figure 1, it is 95\% confident that the first autocorrelation is non-random. 
        This is supported by a significantly low p-value. This suggest that
        the temperature is significantly impacted by the previous year but the impact recorded is weak. 

    \end{document}
**********************************************************************

Testing TAutoCorr.tex...

======================================================================
Inspecting script file MyBars.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 29 2018
# Description: Annotating Histogram

rm(list = ls()) 
graphics.off() 

#Packages 
library(ggplot2)

a <- read.table("../Data/Results.txt", header = TRUE)

head(a)

a$ymin <- rep(0, dim(a)[1]) # append a column of zeros

# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
    x = x,
    ymin = ymin,
    ymax = y1,
    size = (0.5)),
    colour = "#E69F00",
    alpha = 1/2, show.legend = FALSE)
  
# Print the second linerange
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y2,
  size = (0.5)
),
colour = "#56B4E9",
alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y3,
  size = (0.5)
),
colour = "#D55E00",
alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
  scale_y_continuous("My y axis") + 
  theme_bw() + 
  theme(legend.position = "none") 

pdf("../Results/MyBars.pdf") # Open blank pdf page using a relative path
print(p)
graphics.off() 
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 

**********************************************************************
         x   y1   y2 y3 Label
1 3.515424 4320 4320  0  <NA>
2 3.533984 2160 2160  0  <NA>
3 3.557647 4320 4320  0  <NA>
4 3.569953 4320 4320  0  <NA>
5 3.578984 8640 8640  0  <NA>
6 3.585665 2160 2160  0  <NA>

**********************************************************************

Encountered error:
Warning message:
Removed 91 rows containing missing values (geom_text). 

======================================================================
Inspecting script file GPDDmap.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: creates a world map and plots data points using maps package

rm(list=ls()) # clears workspace

library(maps)
# loads maps package

load("../Data/GPDDFiltered.RData") #loads data from Data directory

names(gpdd)
head(gpdd)

lat <- gpdd[,2] # comma puts columns and not default row 
print("The Latitude coordinates are:")
print(lat) # lattitude data assigned to variable lat

long <- gpdd[,3] # comma puts columns and not default row 
print("The Longitudinal coordinates are:")
print(long) # longitude data assigned to variable long

map("world", fill=TRUE, col="white", bg="lightblue", ylim=c(-60, 90), mar=c(0,0,0,0))
# map funtions creates a base map of the "world". 
points(long,lat, col="purple", pch=16)
# points funtion plots location of species using longitude (long) and latitude (lat) data
#   on world map previous created

# most of the data is in the western countries.
# In europe, cluster occurs in Britain. 
# Also within countries where sampling occurs there are clusters observed.
# for example USA, dense clustering occurs along west coast as compared with the other regions,
# such as the east coast, southern and mid western states. 
# Thus there is a strong sample bias and is therefore not representative 
# of global vertebrate populations. 

**********************************************************************

Testing GPDDmap.R...

Output (only first 500 characters): 

**********************************************************************
[1] "common.name" "lat"         "long"       
             common.name   lat    long
1        Atlantic salmon 60.00   10.00
2            Pink salmon 45.62 -121.97
3              Great tit 51.63    1.08
4 Eurasian oystercatcher 51.70   -5.15
5                Skylark 51.70   -5.15
6               Starling 51.70   -5.15
[1] "The Latitude coordinates are:"
  [1]  60.00  45.62  51.63  51.70  51.70  51.70  51.70  51.70  55.67  52.00
 [11]  55.00  55.00  55.00  55.00  55.00  55.00  55.00  55.00  52.00  
**********************************************************************

Code ran without errors

Time consumed = 0.39637s

======================================================================
Inspecting script file control.R...

File contents are:
**********************************************************************
#!/usr/bin/env Rscript
# Author: David Scott
# Contact: david.scott18@imperial.ac.uk
# Date:  October 24 2018
# Description: Example of control flow constructs in R

rm(list=ls()) # clears workspace

## Some code exemplifying control flow constructs in R

## If statement
a <- TRUE
if (a == TRUE){
    print ("a is TRUE")
    } else {
    print ("a is FALSE")
}

## On a single line
z <- runif(1) ##random number
if (z <= 0.5) {
    print ("Less than a quarter")
    }

## For loop using a sequence 
for (i in 1:100){
    j <- i * i
    print(paste(i, " squared is", j ))
    }

## For loop over vector of strings
for(species in c('Heliodoxa rubinoides', 
                'Boissonneaua jardini',
                'Sula nebouxii'))
{
    print(paste('The species is', species))
}

## for loop using a vector
v1 <- c("a", "bc", "def")
for (i in v1){
    print(i)
}

## While loop 
i <- 0
while (i<100){
    i <- i+1
    print(i^2)
}
**********************************************************************

Testing control.R...

Output (only first 500 characters): 

**********************************************************************
[1] "a is TRUE"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "11  squared is 121"
[1] "12  squared is 144"
[1] "13  squared is 169"
[1] "14  squared is 196"
[1] "15  squared is 225"
[1] "16  squared is 256"
[1] "17  squared is 289"
[1] "18  squared is 324"
[1] "19  squared is 361"
[1] "20  squared is 400"
[1] "2
**********************************************************************

Code ran without errors

Time consumed = 0.09461s

======================================================================
======================================================================
Finished running scripts

Ran into 12 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 99.0

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!